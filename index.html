<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<!-- jQuery library -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>

<!-- Latest compiled JavaScript -->
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
<title>
CGPA underflow
</title>
<style>
.yehojaebas
{
	background-color: #dddddd;
}
</style>
</head>

<body  style="background-color: #365899;">
<div class="container-fluid">
<p class="text-center" style="color:#dddddd;font-size: 100px;"><strong>Segment tree tutorial</strong></p>
<div class="yehojaebas">
<br><br><br>
<p style="font-size: 25px;">Hello Guys,<br><br>
My name is <strong>Nilesh tiwari</strong>,<br><br>
I am from thakur college of engineering and technology in mumbai.<br><br>
So this is a tutorial of Segment tree, a topic which is famous and easy to understand and you often get to see problems on this topic in various contests.<br><br>
(prerequisite-> binary search,recusion)<br><br>
st -> segment tree array<br>
A -> original array<br>
q -> number of queries<br>
n -> array of size <br> 
left -> left child<br>
right -> right child<br>
index -> current index in st[] array<br>
min(a,b) -> returns minimum of a and b<br>
<strong>all codes are in c++</strong>
<br>
<br><br>
So, What exactly is a "Segment tree"?<br><br>
Suppose you get a question in a interview that:<br><br>
Q.You have an array A[] of size n(1<=n<=100000) and you have to answer q(1<=q<=100000) queries in each query, You are given two integer L and R (1<=L<=R<=N) and you have to find minimum of A[L] to A[R].(1<=A[i]<=1000000000)<br><br>
(generally questions in technical interview of companies are harder than this)<br><br>
Now a normal solution coming into your mind (if you haven't read about segment tree) is running a loop for each query <br><br>
Like this:<br><br>
<pre style="font-size: 15px;">
<code>
#include<iostream>
using namespace std;
int A[100005];
int main()
{
  int n;
  scanf("%d",&n);//taking n
  int i;
  //taking array
  for(i=1;i<=n;i++)
  {
    scanf("%d",&A[i]);
  }
  int q;
  scanf("%d",&q);//enter q
  for(i=1;i<=q;i++)
  {
    int L,R;
    scanf("%d %d",&L,&R);//range in which we have to find minimum value
    int mn=2000000000;
    for(int j=L;j<=R;j++)
    {
      mn=min(mn,A[j]);
    }
    printf("%d\n",mn);
  }
  return 0;
}	
</code>
OUTPUT:
5
4 2 5 6 1
3
1 3
2
3 4
5
1 5
1
</pre>
</p>
<br><br>
<p style="font-size: 25px;">
But this code will run in time limit (2 sec) in given constraints?<br><br>
n<=10^5 and q<=10^5<br><br>
so in worst case n*q=10^10<br><br>
which will give <strong>"TIME LIMIT EXCEEDED"</strong>. (and i hate this error -.-)<br><br>
your code will run in 2 sec if in worst case code runs in <=10^7<br><br>
This is where segment tree helps. <br><br>
With segment tree we can process each query in <strong>log(R-L+1)</strong><br>
So, in worst case complexity is <strong>O(q*logn)</strong> (100000*17 .... log(100000)<=17)<br>
<br>
In segment tree each node is represented by a position in segment tree array(st[])<br>
each node stores answer for a range <br>
first node(st[1] ) stores answer for 1 to n.<br>
then st[2](1*2) stores answer for 1 to ((1+n)/1).<br>
and st[3](1*2+1) stores answer for ((1+n)/2)+1 to n .... and so on.<br>
range of leaf nodes is 1.<br>
Suppose we have array of size 8 <br>
4 5 2 4 6 1 6 7 
<br>
then segment tree would look like this<br><br>
</p>
<div style="padding-left:400px">
<img  src="https://lh3.googleusercontent.com/jYOi4CQpXDbcJNMUCwT65SS54x74PHHaZtJNny0KHm2ikttRFY2qerc4rdFEJahrrFHK3XHWkd57UxKOPVTWQnAysR0BZjEnmmQ1Ht44jY7a8OJ27bZGqNi_8OJw5UgcEbRNQZQypUiVd-y95DLDvK8F7IZD9HygXdtqj_5WT9YiS4gQVQSAlG9ZOVR4U-B3zU1cPiVFVXcM-udPmR_sI4cf5D2BlTglVye95hC6VdOGTfZ6E4Gg4Nl_fMllSKEnyXkQX1vmMXjCMaF1kLQeVrLm5kfTgcmdYX_8_ylWvE856N7fFGx20WIRtf_V55DQW1C7xWEnJf_r2ey5xMtg1yRqyOf6kN03cjHEMGNmbjAf6U3bWJTpVLwejzGfWRvAjfYjyk3CypQAXwEZ5KcQ7xxFIfbHBh6SQeCQY_SdNWlGdLl8dFJZawoIcx78qjEwd7Z_oeK-93ylLM3Bg_JIdu7D-VFP4ehUzkGRXCS_qT315SsBwEOqmKx64BwvXlCZMWCmiLSmfBP6K3h98jSvOt6V1lE6Smx6gOa_ZSYdVnFT5sOSB3msklWU8GAmVAXEBJ409KGe-TyX4qfD59v_xY3kyqfulXZw0IPEp40ic3doNHuXjT0Vp0Mq=w525-h627-no">
</div>
<br>
<p style="font-size:25px;">
childs of ith index will have (2i) and (2i+1) index, node with range 1 is leaf node<br>
segment tree is just like a binary tree each node have 2 child or 0 child<br>
<br>
So, How to construct a segment tree for given question?
<br><br>
</p>
<pre style="font-size: 15px;">

<code >
void construct(int index,int low,int high)
{
if(low==high)//lenght of range==1
{
st[index]=A[low];
return;
}

int mid=(low+high)/2;

construct(index+index,low,mid);//left child
construct(index+index+1,mid+1,high);//right child

st[index]=min(st[index+index],st[index+index+1]);//updating current node according to child nodes

}
</code>
</pre>
<br><br>
<p style="font-size:25px">
as you can see complexity for construction is O(n) as there are total 2n-1 nodes<br><br>
Now how can we process a query 
so the query we want process is L,R then
<br><br>
when we process a query in range <strong>L,R</strong> and currently we are in range <strong>low</strong> to <strong>high</strong><br><br>
There are three cases <br>
1)current range is inside the query range (low>=L and high<=R)
  in that case you just need to return the value on current node<br>
2)current range does not intersect with query range (low>R or high< L) in that case you just need to return max value that an element can have in the array (1000000000 is also fine and INT_MAX will also work)
<br>
3)current range intersect with query range and in that case we need to process left child and right child
<br><br>
</p>
<pre style="font-size: 15px;">
<code>
int query(int index,int low,int high,int L,int R)
{

//low-> lower index of current range
//high-> upper index of current range

if(low>=L && high<=R)//current range is inside the query range
{
return st[index];
} 

if(low > R || high < L || low>high)//current range doesn't intersect with query range
{
return 2000000000;
}

int mid=(low+high)/2;

int left=query(index+index,low,mid,L,R);
int right=query(index+index+1,mid+1,high,L,R);

return min(left,right);

}
</code>
</pre>
<p style="font-size:25px">
<br><br>
In the above given example of array of size 8 if we need to get answer for range 3 to 7 then the process will be something like this...
<br><br>
</p>
<div style="padding-left:400px;">
<img src="https://lh3.googleusercontent.com/c_Egf_1fBEh5qzJYUYbzGgw5URd7FbedFKhjgacdOd75i_DfSx4veESyxgoWKV7Cyvd5MYWJngP4Dj4XFWDTZptTV56Bg_-DA4ZsTEr-0Pvgf__3h97FZ7tx8ZEjq28z9HkVA-oy810XMtNpEQ_OtWJwXGqM-W7InWPG8IxPFwST7xXv-RX9Dz3vfMvV5xjl6yHSQXqNVWWI8Tzlrl6HMeAW0k_7ZcCCbZF_PcDZDLG0jCjTdHJ3xGQoyi4dva0YhinPNUlxgP7PLrBYJRpQZjP-mHx7IDNXbpldnvdiXEWSu6m50kgqNTFPQtNun9KLl2I2ZdvGw5CV00x-ub4okMQFNa8KcSvrc8dfQc35sXA1J3_8m90Zjc3bPGAsQar7EvGyppSoculbapWUI7Tk9Xx_0_vH-s2GxsdGUK_6fdOs_TTuCQ8bs7e0DDc-tCxqo2yBXnCQOUs3b1wME8NKV_g_GKyAOH8qNOab-TBa-EhW5IvjutDP0CvoETuPekUm9fiYnTYqy4Tu1kiHea5bu17w87janoiglvQUZ-heXOwAom5qftZHrsfDWu9GpIm7CZz85eemgXGsOIfD-dyKhmS-cPeUBMl67j9GIsxk2OlIrFuKwWZf40z1=w381-h676-no" alt="segment tree query">
</div>
<br><br>
<p style="font-size: 25px;">
	As you can see range of node 5,6,14 was totally inside the query range so it returned its value without processing its childs <br>
<br> so the solution for given question is 
</p>
<pre style="font-size: 15px;">
<code>
#include<iostream>

using namespace std;

int A[100005];

int st[400020];//segment tree array

void construct(int index,int low,int high)
{
if(low==high)//lenght of range==1
{
st[index]=A[low];
return;
}

int mid=(low+high)/2;

construct(index+index,low,mid);//left child
construct(index+index+1,mid+1,high);//right child

st[index]=min(st[index+index],st[index+index+1]);//updating current node according to child nodes

}
int query(int index,int low,int high,int L,int R)
{

//low-> lower index of current range
//high-> upper index of current range

if(low>=L && high<=R)//current range is inside the query range
{
return st[index];
} 

if(low > R || high < L || low>high)//current range doesn't intersect with query range
{
return 2000000000;
}

int mid=(low+high)/2;

int left=query(index+index,low,mid,L,R);
int right=query(index+index+1,mid+1,high,L,R);

return min(left,right);

}
int main()
{
  int n;

  scanf("%d",&n);//taking n

  int i;

  //taking array

  for(i=1;i<=n;i++)
  {
    scanf("%d",&A[i]);
  }

  construct(1,1,n);

  int q;
  scanf("%d",&q);

  for(i=1;i<=q;i++)
  {
    int l,r;

    scanf("%d %d",&l,&r);

    printf("%d\n",query(1,1,n,l,r));
  }
  return 0;
}
OUTPUT:
5
4 2 5 6 1
3
1 3
2
3 4
5
1 5
1
</code>
</pre>
<p style="font-size: 25px;">
<br><br>
This code will run in <strong>O(q*logn)</strong> in worst case.<br><br>
segment tree is very useful when it comes to range queries like finding min,max,xor,sum of a range.<br>
<br>
So, This is it<br>
I hope you learned somethin new from this tutorial<br>
There is a update part of segment tree and i will cover that topic very soon.
<br>
<br>
for any help you can contact me at <strong>tnilesh02@gmail.com</strong>s
<br>
<br>
<br> 
</p>
</div>
</div>
</body>
</html>